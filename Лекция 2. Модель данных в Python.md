# Лекция 2. Модель данных в Python.

> У Гвидо поразительное эстетическое чувство дизайна языка. Я встречал многих замечательных проектировщиков языков программирования, 
> создававших теоретически красивые языки, которыми никто никогда не пользовался, а Гвидо - один из тех редких людей, 
> которые могут создать язык, немного недотягивающий до теоретической красоты, зато такой, что писать на нём программы в радость.
>
> Джим Хагьюнин,  
> *автор Jython, соавтор AspectJ, архитектор .Net DLR*

## Модель данных как каркас для объектов языка

Язык Python выделяется согласованностью поведения различных объектов. Длину любого объекта obj можно попытаться определить 
с помощью синтаксической конструкции len(obj). Обращение к элементу также выглядит однообразно для любого итерируемого объекта 
obj: obj[key] и т.п. Всё это достигается тем, что в языке заранее определена модель данных (формализована структура) для 
различных его структурных блоков, таких как последовательности, итераторы, функции, классы и т.п.
 
Знание и понимание модели данных позволяет адаптировать объекты написанных самостоятельно классов к использованию стандартными питоновскими
синтаксическими конструкциями. Например, за синтаксической конструкцией получения элемента коллекции obj[key] стоит вызов специального метода объекта 
obj \_\_getitem\_\_: obj.\_\_getitem\_\_(key). Учитывая это, мы можем определить свой класс MyCollection с методом \_\_getitem\_\_, и тогда
для выбора элемента из его экземпляра my_collection можно будет воспользовать конструкцией my_collection[key].

Такие методы, неявно используемые синтаксическими конструкциями языка для выполнения каких-то действий над объектами, 
называются специальными, а их имена начинаются и заканчиваются двумя знаками подчеркивания. Благодаря специальным методам 
(которые также иногда называют dunder-методами или магическими методами) объекты могут реализовывать, поддерживать и взаимодействовать 
с базовыми конструкциями языка, среди которых:

* итерирование;
* коллекции;
* доступ к атрибутам;
* перегрузка операторов;
* вызов функций и методов;
* создание и уничтожение объектов;
* представление и форматирование строк;
* управляемые контексты (блоки with).

Работая со специальными методами следует понимать, что они предназначены для вызова интерпретатором, а не вами. То есть в 
большинстве ситуаций они вызываются синтаксическими конструкциями неявно в процессе выполнения программы, а программа не содержит
прямых обращений к ним.

## Колода карт на Python

Реализуем свой класс FrenchDeck для колоды карт со специальными методами \_\_len\_\_ и \_\_getitem\_\_:

```python
import collections 

Card = collections.namedtuple('Card', ['rank', 'suit']) 

class = FrenchDeck:

    ranks = [str(n) for range(2, 11)] + list('JQKA')
    suits = 'spades diamonds clubs hearts'.split()
    
    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits
                                        for rank in self.ranks]
    
    def __len__(self):
        return len(self._cards)
        
    def __getitem__(self, position):
        return self._cards[position]
```

Теперь в сеансе интерактивной оболочки посмотрим, что мы можем с ним делать:

```python
>>> deck = FrenchDeck()
>>> len(deck)
52
>>> deck[0]
Card(rank='2', suit='spades')
>>> deck[-1]
Card(rank='A', suit='hearts')
>>> from random import choice
>>> choice(deck)
Card(rank='K', suit='spades')
>>> deck[:2]
[Card(rank='2', suit='spades'), Card(rank='3', suits='spades')]
>>> deck[12::13]
[Card(rank='A', suits='spades'), Card(rank='A', suits='diamonds'), Card(rank='A', suits='clubs'), Card(rank='A', suits='hearts')]
>>> for card in reversed(deck[:2]):
...     print(card)
Card(rank='3', suits='spades')
Card(rank='2', suit='spades')
>>> Card('Q', 'hearts') in deck
True
>>> Card('7', 'beasts') in deck
False
```

Хотя класс FrenchDeck неявно наследует объект object, его функциональность не наследуется, а является следствием использования 
модели данных и композиции. Реализация методов \_\_len\_\_ и \_\_getitem\_\_ заставляет класс вести себя подобно стандартной последовательности 
и позволяет использовать в работе с ним базовые средства языка (итерирование, получение среза). 
Благодаря композиции методы \_\_len\_\_ и \_\_getitem\_\_ класса FrenchDeck перепоручают работу объекту self._cards типа list.

## Простой класс двумерного вектора

```python
from math import hypot

class Vector:
    
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
        
    def ___repr__(self):
        return 'Vector(%r, %r)' % (self.x, self.y)
    
    def ___abs___(self):
        return hypot(self.x, self.y)
        
    def __bool__(self):
        return bool(abs(self))
        
    def __add__(self, other):
        x = self.x + other.x
        y = self.x + other.y
        return Vector(x, y)
        
    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)
```

Сеанс оболочки:

```python
>>> v1 = Vector(2, 4)
>>> v2 = Vector(2, 1)
>>> v1 + v2 
Vector(4, 5)
>>> v = Vector(3, 4)
>>> abs(v)
5.0
>>> v * 3
Vector(9, 12)
>>> abs(v * 3)
15.0
>>> bool(v)
True
```

Благодаря перегрузке операторов Python предлагает большой набор числовых типов.

## Перечень специальных методов

### Имена специальных методов для операторов

Категория | Имена методов
----------|--------------
Унарные числовые операторы | \_\_neg\_\_ -, \_\_pos\_\_ +, \_\_abs\_\_ abs()
Операторы сравнения | \_\_lt\_\_ <, \_\_le\_\_ <=, \_\_eq\_\_ ==, \_\_ne\_\_ !=, \_\_gt\_\_ >, \_\_ge\_\_ >=
Арифметические операторы | \_\_add\_\_ +, \_\_sub\_\_ -, \_\_mul\_\_ \*, \_\_truediv\_\_ /, \_\_floordiv\_\_ //, \_\_mod\_\_ %, \_\_divmod\_\_ divmod(), \_\_pow\_\_ \*\* или pow(), \_\_round\_\_ round() 
Инверсные арифметические операторы | \_\_radd\_\_, \_\_rsub\_\_, \_\_rmul\_\_, \_\_rtruediv\_\_, \_\_rfloordiv\_\_, \_\_rmod\_\_, \_\_rdivmod\_\_, \_\_rpow\_\_
Арифметические операторы присваивания | \_\_iadd\_\_, \_\_isub\_\_, \_\_imul\_\_, \_\_itruediv\_\_, \_\_ifloordiv\_\_, \_\_imod\_\_, \_\_ipow\_\_
Поразрядные операторы | \_\_invert\_\_ ~, \_\_lshift\_\_ <<, \_\_rshift\_\_ >>, \_\_and\_\_ &, \_\_or\_\_ \|, \_\_xor\_\_ ^
Инверсные поразрядные операторы | \_\_rlshift\_\_, \_\_rrshift\_\_, \_\_rand\_\_, \_\_rxor\_\_, \_\_ror\_\_
Поразрядные операторы составного присваивания | \_\_ilshift\_\_, \_\_irshift\_\_, \_\_iand\_\_, \_\_ixor\_\_, \_\_ior\_\_ 

### Остальные имена специальных методов 

Категория | Имена методов
----------|--------------
Представление в виде строк и байтов | \_\_repr\_\_, \_\_str\_\_, \_\_format\_\_, \_\_bytes\_\_
Преобразование в число | \_\_abs\_\_, \_\_bool\_\_, \_\_complex\_\_, \_\_int\_\_, \_\_float\_\_, \_\_hash\_\_, \_\_index\_\_
Эмуляция коллекций | \_\_len\_\_, \_\_getitem\_\_, \_\_setitem\_\_, \_\_delitem\_\_, \_\_contains\_\_
Итерирование | \_\_iter\_\_, \_\_reversed\_\_, \_\_next\_\_
Эмуляция объектов, допускающих вызов | \_\_call\_\_
Управление контекстом | \_\_enter\_\_, \_\_exit\_\_
Создание и уничтожение объектов | \_\_new\_\_, \_\_init\_\_, \_\_del\_\_
Управление аттрибутами | \_\_getattr\_\_, \_\_getattribute\_\_, \_\_setattr\_\_, \_\_delattr\_\_, \_\_dir\_\_
Дескрипторы атрибутов | \_\_get\_\_, \_\_set\_\_, \_\_delete\_\_
Сервисы классов | \_\_prepare\_\_, \_\_instancecheck\_\_, \_\_subclasscheck\_\_
